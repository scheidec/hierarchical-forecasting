<!DOCTYPE html>
<html>
  <head>
    <title>Hierarchical Time Series Forecasting</title>
    <meta charset="utf-8">
    <meta name="author" content="Caleb Scheidel" />
    <link rel="stylesheet" href="mc-xaringan.css" type="text/css" />
    <link rel="stylesheet" href="mc-xaringan-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Hierarchical Time Series Forecasting
### Caleb Scheidel
### 2018/11/30

---


layout: true
background-color: #fafaef
&lt;div class="my-footer"&gt;&lt;img src="mc_logo_rectangle.png" style="height: 30px;"/&gt;&lt;/div&gt;



---

## Motivation

- In many applications time series can be organized in a hierarchical structure
  - e.g. by geography, product types, market segments
    - data that can be _disaggregated_ 

- It is common to produce disaggregated forecasts based on the bottom-level time series, but what if we wanted to also forecast the intermediate and top-level series?
  - We would expect the forecasts to be _coherent_
    - add up in a manner that is consistent with the hierarchical structure

---

## Hierarchical Time Series

![](two-level-hierarchical-diagram.png)

- AA + AB + AC = A

- A + B = Total

---

## Hierarchical Time Series

For any time _t_, the observations of the bottom-level series will aggregate to the observations of the series above.

- *S* matrix

![](s-matrix.png)


---

## Methods

- Top-down
- Bottom-up
- Middle-out
- Optimal Combination
- Trace Minimization

---

## US National Parks Visitor Data

- From: https://data.world/inform8n/us-national-parks-visitation-1904-2016-with-boundaries
  - scraped from source [here](https://irma.nps.gov/Stats/SSRSReports/National%20Reports/Annual%20Summary%20Report%20(1904%20-%20Last%20Calendar%20Year)


```r
nps &lt;- read_csv("../data/All National Parks Visitation 1904-2016.csv") %&gt;% 
  janitor::clean_names() %&gt;% 
  select(park_name = unit_name,
         park_code = unit_code,
         park_type = unit_type,
         state,
         region,
         year      = year_raw,
         visitors) %&gt;% 
  arrange(year) %&gt;% 
  filter(year != "Total") %&gt;% 
  mutate(year = as.numeric(year)) %&gt;% 
  filter(park_type == "National Park") %&gt;% 
  filter(park_name != "Denali National Preserve") # duplicate
  #as_tsibble(index = year, key = id(park_code))
```

---


```r
# by park
nps %&gt;% 
  ggplot(aes(x = year, y = visitors, colour = park_code)) +
  geom_line() + theme(legend.position = "bottom") + 
  guides(colour=guide_legend(ncol=11))
```

![](hierarchical-forecasting_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;

---


```r
# by state
nps %&gt;% 
  group_by(state, year) %&gt;% 
  summarise(visitors = sum(visitors)) %&gt;% 
  ggplot(aes(x = year, y = visitors, colour = state)) +
  geom_line() + theme(legend.position = "bottom") +
  guides(colour=guide_legend(ncol = 11))
```

![](hierarchical-forecasting_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;

---


```r
# by region
nps %&gt;% 
  group_by(region, year) %&gt;% 
  summarise(visitors = sum(visitors)) %&gt;% 
  ggplot(aes(x = year, y = visitors, colour = region)) +
  geom_line() + theme(legend.position = "bottom")+
  guides(colour=guide_legend(ncol = 7))
```

![](hierarchical-forecasting_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;

---

## `hts` package


```r
library(hts)
```

---

## Bottom-up method

- Advantage: no information is lost due to aggregation
- Disadvantage: bottom-level data can be quite noisy and more challenging to model and forecast

---

## Top-down method

- Average historical proportions
  - Each proportion reflects the average of the historical proportions of the bottom-level series over the period _t_ relative to the total aggregate `\(y_{t}\)`
  
- Proportions of the historical averages
  - Each proportion captures the average historical value of the bottom-level series relative to the average value of the total aggregate `\(y_{t}\)`

- Forecasted proportions
  - first generate _h_-step-ahead base forecasts for all the series independently
  - at level 1 we calculate the proportion of each _h_-step-ahead base forecasts

---

## Middle-out method

- Combines bottom-up and top-down approaches
  - "middle level" is chosen and base forecasts are generated for all the series of this level and below
  - for series above the middle level, forecasts are generated using bottom up approach by aggregating the "middle level" base forecasts upwards

---

## Other Methods

- It is possible to forecast all series at all levels independently, but this has the undesirable consequence of the higher level forecasts not being equal to the sum of the lower level forecasts.  Adjustments can be done in an ad-hoc manner, but prediction intervals cannot be computed.

- Forecast reconciliation
  - can be used for h or g time series
  - clusters may be correlated
  - prediction intervals can be computed

---

## Other Methods

- Optimal Combination
- Trace Minimization
  
---  
  
## Optimal Combination

- Proposed by Hyndman, et al (2011)
  - allows optimal point forecasts to be produced
  - advantages:
    - base forecasts can come from any model, or can be judgemental forecasts
      - ad-hoc adjustments can be incorporated
      
---

## Trace Minimization

- Proposed by Hyndman, et al (2018)
- `hts::MinT()` function

---

Setting up the `hts` object.


```r
nps_ts &lt;- nps %&gt;%
  arrange(region, state) %&gt;% 
  mutate(park_code = paste0(region, state, park_code)) %&gt;% 
  select(park_code, year, visitors) %&gt;%
  spread(park_code, visitors) %&gt;% 
  as_tsibble(index = "year") %&gt;% 
  as.ts()

nps_hts &lt;- hts(nps_ts,
               characters = c(2, 2, 4))

names(nps_hts$labels) &lt;- c("Total", "Region", "State", "Park")
```

---

Now we can forecast.


```r
nps_fcasts &lt;- forecast(
  nps_hts,
  h = 5,                  # forecast next 5 years (2017-2021)
  method = "comb",        # optimal combination
  fmethod = "ets",        # exponential smoothing
  keep.fitted = TRUE,
  keep.resid = TRUE
)

metrics &lt;- nps_fcasts %&gt;% 
  summary() %&gt;% 
  broom::tidy() %&gt;% 
  rename(metric = .rownames)

metrics %&gt;%
  mutate(park = "SENCGRSM") %&gt;% 
  select(park, metric, `Optimal Combination` = SENCGRSM)
```

---


```r
plot(nps_fcasts, levels = c(0, 1))
```

![](hierarchical-forecasting_files/figure-html/unnamed-chunk-8-1.png)&lt;!-- --&gt;

---


```r
plot(nps_fcasts, levels = c(2, 3))
```

![](hierarchical-forecasting_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
