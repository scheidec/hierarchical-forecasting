<!DOCTYPE html>
<html>
  <head>
    <title>Hierarchical Time Series Forecasting</title>
    <meta charset="utf-8">
    <meta name="author" content="Caleb Scheidel" />
    <link rel="stylesheet" href="mc-xaringan.css" type="text/css" />
    <link rel="stylesheet" href="mc-xaringan-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Hierarchical Time Series Forecasting
### Caleb Scheidel
### 2018/11/30

---


layout: true
background-color: #fafaef
&lt;div class="my-footer"&gt;&lt;img src="mc_logo_rectangle.png" style="height: 30px;"/&gt;&lt;/div&gt;



---

## Motivation

- Why would we be interested in hierarchically structured time series?

---

# Forecasting

- General overview of forecasting

---

## Hierarchical Time Series

- More detail on "hierarchical" structure
  - visualize an example

---

## Optimal Combination

- Proposed by Hyndman, et al (2011)

---

## Trace Minimization

- Proposed by Hyndman, et al (2018)

---

## `hts` package


```r
library(hts)
```


---

## Bottom-up method

- Advantage: no information is lost due to aggregation
- Disadvantage: bottom-level data can be quite noisy and more challenging to model and forecast

---

## Top-down method

- Average historical proportions
  - Each proportion reflects the average of the historical proportions of the bottom-level series over the period _t_ relative to the total aggregate `\(y_{t}\)`
  
- Proportions of the historical averages
  - Each proportion captures the average historical value of the bottom-level series relative to the average value of the total aggregate `\(y_{t}\)`

- Forecasted proportions
  - first generate _h_-step-ahead base forecasts for all the series independently
  - at level 1 we calculate the proportion of each _h_-step-ahead base forecasts

---

## Middle-out method

- Combines bottom-up and top-down approaches
    - "middle level" is chosen and base forecasts are generated for all the series of this level and below
    - for series above the middle level, forecasts are generated using bottom up approach by aggregating the "middle level" base forecasts upwards

---

## US National Parks Visitor Data


```r
nps &lt;- read_csv("../data/All National Parks Visitation 1904-2016.csv") %&gt;% 
  janitor::clean_names() %&gt;% 
  select(park_name = unit_name,
         park_code = unit_code,
         park_type = unit_type,
         state,
         region,
         year      = year_raw,
         visitors) %&gt;% 
  arrange(year) %&gt;% 
  filter(year != "Total") %&gt;% 
  mutate(year = as.numeric(year)) %&gt;% 
  filter(park_type == "National Park") %&gt;% 
  filter(park_name != "Denali National Preserve") %&gt;%
  as_tsibble(index = year, key = id(park_code))
```

---


```r
# by park
nps %&gt;% 
  ggplot(aes(x = year, y = visitors, colour = park_code)) +
  geom_line()
```

![](hierarchical-forecasting_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;

---


```r
# by state
nps %&gt;% 
  group_by(state, year) %&gt;% 
  summarise(visitors = sum(visitors)) %&gt;% 
  ggplot(aes(x = year, y = visitors, colour = state)) +
  geom_line()
```

![](hierarchical-forecasting_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;

---


```r
# by region
nps %&gt;% 
  group_by(region, year) %&gt;% 
  summarise(visitors = sum(visitors)) %&gt;% 
  ggplot(aes(x = year, y = visitors, colour = region)) +
  geom_line()
```

![](hierarchical-forecasting_files/figure-html/unnamed-chunk-5-1.png)&lt;!-- --&gt;

---

## Data

Divide the data into two parts, the first 90% of each series use as the training set for estimating parameters and the last 10% as a test set.  Are the differences in the forecasting results statistically significant?

---

## Other Methods

It is possible to forecast all series at all levels independently, but this has the undesirable consequence of the higher level forecasts not being equal to the sum of the lower level forecasts.  Adjustments can be done in an ad-hoc manner, but prediction intervals cannot be computed.
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
