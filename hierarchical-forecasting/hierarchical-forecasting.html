<!DOCTYPE html>
<html>
  <head>
    <title>Hierarchical Time Series Forecasting</title>
    <meta charset="utf-8">
    <meta name="author" content="Caleb Scheidel" />
    <link rel="stylesheet" href="mc-xaringan.css" type="text/css" />
    <link rel="stylesheet" href="mc-xaringan-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Hierarchical Time Series Forecasting
### Caleb Scheidel
### 2018/11/30

---


layout: true
background-color: #fafaef
&lt;div class="my-footer"&gt;&lt;img src="mc_logo_rectangle.png" style="height: 30px;"/&gt;&lt;/div&gt;



---

## Motivation

- Why would we be interested in hierarchically structured time series?

---

# Forecasting

- General overview of forecasting

---

## Hierarchical Time Series

- More detail on "hierarchical" structure
  - visualize an example

---

## US National Parks Visitor Data

- From: https://data.world/inform8n/us-national-parks-visitation-1904-2016-with-boundaries
  - scraped from source here: https://irma.nps.gov/Stats/SSRSReports/National%20Reports/Annual%20Summary%20Report%20(1904%20-%20Last%20Calendar%20Year)


```r
nps &lt;- read_csv("../data/All National Parks Visitation 1904-2016.csv") %&gt;% 
  janitor::clean_names() %&gt;% 
  select(park_name = unit_name,
         park_code = unit_code,
         park_type = unit_type,
         state,
         region,
         year      = year_raw,
         visitors) %&gt;% 
  arrange(year) %&gt;% 
  filter(year != "Total") %&gt;% 
  mutate(year = as.numeric(year)) %&gt;% 
  filter(park_type == "National Park") %&gt;% 
  filter(park_name != "Denali National Preserve") %&gt;%
  as_tsibble(index = year, key = id(park_code))
```

---


```r
# by park
nps %&gt;% 
  ggplot(aes(x = year, y = visitors, colour = park_code)) +
  geom_line() + theme(legend.position = "bottom") + 
  guides(colour=guide_legend(ncol=11))
```

![](hierarchical-forecasting_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;

---


```r
# by state
nps %&gt;% 
  group_by(state, year) %&gt;% 
  summarise(visitors = sum(visitors)) %&gt;% 
  ggplot(aes(x = year, y = visitors, colour = state)) +
  geom_line() + theme(legend.position = "bottom") +
  guides(colour=guide_legend(ncol = 11))
```

![](hierarchical-forecasting_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;

---


```r
# by region
nps %&gt;% 
  group_by(region, year) %&gt;% 
  summarise(visitors = sum(visitors)) %&gt;% 
  ggplot(aes(x = year, y = visitors, colour = region)) +
  geom_line() + theme(legend.position = "bottom")+
  guides(colour=guide_legend(ncol = 7))
```

![](hierarchical-forecasting_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;

---

## `hts` package


```r
library(hts)
```

---

## Bottom-up method

- Advantage: no information is lost due to aggregation
- Disadvantage: bottom-level data can be quite noisy and more challenging to model and forecast

---

## Top-down method

- Average historical proportions
  - Each proportion reflects the average of the historical proportions of the bottom-level series over the period _t_ relative to the total aggregate `\(y_{t}\)`
  
- Proportions of the historical averages
  - Each proportion captures the average historical value of the bottom-level series relative to the average value of the total aggregate `\(y_{t}\)`

- Forecasted proportions
  - first generate _h_-step-ahead base forecasts for all the series independently
  - at level 1 we calculate the proportion of each _h_-step-ahead base forecasts

---

## Middle-out method

- Combines bottom-up and top-down approaches
  - "middle level" is chosen and base forecasts are generated for all the series of this level and below
  - for series above the middle level, forecasts are generated using bottom up approach by aggregating the "middle level" base forecasts upwards

---

## Other Methods

- It is possible to forecast all series at all levels independently, but this has the undesirable consequence of the higher level forecasts not being equal to the sum of the lower level forecasts.  Adjustments can be done in an ad-hoc manner, but prediction intervals cannot be computed.

- Forecast reconciliation
  - can be used for h or g time series
  - clusters may be correlated
  - prediction intervals can be computed

---

## Other Methods

- Optimal Combination
- Trace Minimization
  
---  
  
## Optimal Combination

- Proposed by Hyndman, et al (2011)
  - allows optimal point forecasts to be produced
  - advantages:
    - base forecasts can come from any model, or can be judgemental forecasts
      - ad-hoc adjustments can be incorporated
      
---

## Trace Minimization

- Proposed by Hyndman, et al (2018)
- `hts::MinT()` function

---

Setting up the `hts` object.


```r
nps_ts &lt;- nps %&gt;%
  as_tibble() %&gt;%
  arrange(region, state) %&gt;% 
  mutate(park_code = paste0(region, state, park_code)) %&gt;% 
  select(park_code, year, visitors) %&gt;%
  spread(park_code, visitors) %&gt;% 
  as_tsibble(index = "year") %&gt;% 
  as.ts()

nps_hts &lt;- hts(nps_ts,
               characters = c(2, 2, 4))

names(nps_hts$labels) &lt;- c("Total", "Region", "State", "Park")
```

---

Now we can forecast.


```r
nps_fcasts &lt;- forecast(
  nps_hts,
  h = 5,                  # forecast next 5 years (2017-2021)
  method = "comb",        # optimal combination
  fmethod = "ets",        # exponential smoothing
  keep.fitted = TRUE,
  keep.resid = TRUE
)

metrics &lt;- nps_fcasts %&gt;% 
  summary() %&gt;% 
  broom::tidy() %&gt;% 
  rename(metric = .rownames)
```

---


```r
plot(nps_fcasts)
```

![](hierarchical-forecasting_files/figure-html/unnamed-chunk-8-1.png)&lt;!-- --&gt;
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
  }
});
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
