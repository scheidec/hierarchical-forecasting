<!DOCTYPE html>
<html>
  <head>
    <title>Hierarchical Time Series Forecasting</title>
    <meta charset="utf-8">
    <meta name="author" content="Caleb Scheidel" />
    <link rel="stylesheet" href="mc-xaringan.css" type="text/css" />
    <link rel="stylesheet" href="mc-xaringan-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Hierarchical Time Series Forecasting
### Caleb Scheidel
### 2018/11/30

---


layout: true
background-color: #fafaef
&lt;div class="my-footer"&gt;&lt;img src="mc_logo_rectangle.png" style="height: 30px;"/&gt;&lt;/div&gt;



---

## Hierarchical Time Series

- In many applications time series can be organized in a hierarchical structure
  - e.g. by geography, product types, market segments
    - data that can be _disaggregated_ 

- It is common to produce disaggregated forecasts based on the bottom-level time series, but what if we wanted to also forecast the intermediate and top-level series?
  - We would expect the forecasts to be _coherent_
    - add up in a manner that is consistent with the hierarchical structure

---

## Hierarchical Time Series

![](two-level-hierarchical-diagram.png)

- AA + AB + AC = A

- A + B = Total

---

## Hierarchical Time Series

For any time _t_, the observations of the bottom-level series will aggregate to the observations of the series above.

- *S* matrix

![](s-matrix.png)


---

## Methods

- Top-down
- Bottom-up
- Middle-out
- Optimal Combination

---

## US National Parks Visitor Data

- From: https://data.world/inform8n/us-national-parks-visitation-1904-2016-with-boundaries
  - scraped from source [here](https://irma.nps.gov/Stats/SSRSReports/National%20Reports/Annual%20Summary%20Report%20(1904%20-%20Last%20Calendar%20Year)


```r
nps &lt;- read_csv("../data/All National Parks Visitation 1904-2016.csv") %&gt;% 
  janitor::clean_names() %&gt;% 
  select(park_name = unit_name,
         park_code = unit_code,
         park_type = unit_type,
         state,
         region,
         year      = year_raw,
         visitors) %&gt;% 
  arrange(year) %&gt;% 
  filter(year != "Total") %&gt;% 
  mutate(year = as.numeric(year)) %&gt;% 
  filter(park_type == "National Park") %&gt;% 
  filter(park_name != "Denali National Preserve") # duplicate
```

---


```r
# by park
nps %&gt;% 
  ggplot(aes(x = year, y = visitors, colour = park_code)) +
  geom_line() + theme(legend.position = "bottom") + 
  guides(colour=guide_legend(ncol=11))
```

![](hierarchical-forecasting_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;

---


```r
# by state
nps %&gt;% 
  group_by(state, year) %&gt;% 
  summarise(visitors = sum(visitors)) %&gt;% 
  ggplot(aes(x = year, y = visitors, colour = state)) +
  geom_line() + theme(legend.position = "bottom") +
  guides(colour=guide_legend(ncol = 11))
```

![](hierarchical-forecasting_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;

---


```r
# by region
nps %&gt;% 
  group_by(region, year) %&gt;% 
  summarise(visitors = sum(visitors)) %&gt;% 
  ggplot(aes(x = year, y = visitors, colour = region)) +
  geom_line() + theme(legend.position = "bottom")+
  guides(colour=guide_legend(ncol = 7))
```

![](hierarchical-forecasting_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;

---

## `hts` package


```r
library(hts)
```

---

## Bottom-up method

- Forecast bottom-level series, then use aggregation (simple addition) to obtain forecasts at higher levels

- Advantage: no information is lost due to aggregation
- Disadvantage: bottom-level data can be noisy and more challenging to forecast

---

## Top-down method

- Forecast the "total" aggregated series, then disaggregate the forecasts

- Advantage: when bottom-level data are noisy, top-down method produces more accurate forecasts
    - useful with low count data
- Disadvantage: loss of information due to aggregation
    - unable to capture individual series characteristics (e.g. special events)

- Several methods (20+) have been developed to disaggregate
    - average historical proportions
    - proportions of the historical averages
    - forecasted proportions

---

## Average historical proportions

- Each proportion, `\(p_{j}\)` reflects the average of the historical proportions of the bottom-level series `\(y_{j,t}\)` over the period _t_ = 1,..., _T_ relative to the total aggregate `\(y_{t}\)`

$$
p_{j} = \frac{1}{T}\sum_{t=1}^{T}{\frac{y_{j,t}}{y_{t}}}
$$
  
---

## Proportions of the historical averages
        
- Each proportion `\(p_{j}\)` captures the average historical value of the bottom-level series `\(y{j,t}\)` relative to the average value of the total aggregate `\(y_{t}\)`

$$
p_{j} = \sum_{t=1}^{T}{\frac{y_{j,t}}{T}} / \sum_{t=1}^{T}{\frac{y_{t}}{T}}
$$

---

## Forecasted proportions

- Developed by Athanasopoulos et al (2009)

1. first generate _h_-step-ahead base forecasts for all the series independently
2. starting from the top level, we calculate the proportion of each _h_-step-ahead base forecast to the aggregate of all the _h_-step-ahead base forecasts at that level
    - these are the _forecasted proportions_, which are used to disaggregate and generate revised forecasts
3. for a _K_-level hierarchy, step 2 is repeated for each node going from top to bottom

---

## Middle-out method

- Combines bottom-up and top-down approaches
    1. "middle level" is chosen and base forecasts are generated for all the series of this level and below
    2. for series above the middle level, forecasts are generated using bottom up approach by aggregating the middle level base forecasts upwards
    3. for series below the middle level, revised forecasts are generated using a top-down approach

---
  
## Optimal Combination

- Proposed by Hyndman, et al (2011)

- advantages:
    - uses _all_ information available within the hierarchy
    - allows for correlations and interactions between series at each level of the hierarchy
    - produces unbiased revised forecasts if base forecasts are unbiased
      
---

## Optimal Combination

---

Setting up the `hts` object.


```r
nps_ts &lt;- nps %&gt;%
  arrange(region, state) %&gt;% 
  mutate(park_code = paste0(region, state, park_code)) %&gt;% 
  select(park_code, year, visitors) %&gt;%
  spread(park_code, visitors) %&gt;% 
  as_tsibble(index = "year") %&gt;% 
  as.ts()

nps_hts &lt;- hts(nps_ts,
               characters = c(2, 2, 4))

names(nps_hts$labels) &lt;- c("Total", "Region", "State", "Park")
```

---

Now we can forecast.


```r
nps_fcasts &lt;- forecast(
  nps_hts,
  h = 5,                  # forecast next 5 years (2017-2021)
  method = "comb",        # optimal combination
  fmethod = "ets",        # exponential smoothing
  keep.fitted = TRUE,
  keep.resid = TRUE
)

metrics &lt;- nps_fcasts %&gt;% 
  summary() %&gt;% 
  broom::tidy() %&gt;% 
  rename(metric = .rownames)

metrics %&gt;%
  mutate(park = "SENCGRSM") %&gt;% 
  select(park, metric, `Optimal Combination` = SENCGRSM)
```

---

Now we can forecast.


```r
hts_fcast_metrics &lt;- function(hts_obj, h, method, fmethod, park, park_name, level = 2) {
  
  park &lt;- enquo(park)
  
  nps_fcasts &lt;- forecast(
    hts_obj,
    h = h,
    method = method,        
    fmethod = fmethod,     
    keep.fitted = TRUE,
    keep.resid = TRUE,
    level = level
  )

  invisible(capture.output(metrics &lt;- summary(nps_fcasts)))
  
  metrics &lt;- metrics %&gt;%   
    broom::tidy() %&gt;% 
    rename(metric = .rownames) %&gt;% 
    mutate(park_name = park_name) %&gt;% 
    select(park_name, metric, !!park) %&gt;%
    spread(metric, !!park) %&gt;% 
    mutate(method = method) %&gt;% 
    select(park_name, method, everything())

  metrics
} 
```

---


```r
hts_methods  &lt;- c("bu",    "tdfp",  "comb", "mo")
hts_fmethods &lt;- c("arima", "arima", "ets",  "ets")

tbl &lt;- hts_methods %&gt;% 
  map2_df(hts_fmethods, ~ hts_fcast_metrics(nps_hts, 5, .x, .y, SENCGRSM, "Great Smoky Mountains"))

tbl %&gt;% 
  knitr::kable()
```



park_name               method         MAE        MAPE       MASE          ME         MPE       RMSE
----------------------  -------  ---------  ----------  ---------  ----------  ----------  ---------
Great Smoky Mountains   bu        295232.8    8.382227   1.174242     -40.951   -2.452122   411902.5
Great Smoky Mountains   tdfp      294739.3    8.862291   1.172280    7307.959   -2.587239   415141.1
Great Smoky Mountains   comb      302983.6   10.228810   1.205070   23087.970    2.536489   423122.6
Great Smoky Mountains   mo        304404.8   10.319153   1.210723   41336.769    2.958275   420905.5

---


```r
plot(nps_fcasts, levels = c(0, 1))
```

![](hierarchical-forecasting_files/figure-html/unnamed-chunk-10-1.png)&lt;!-- --&gt;

---


```r
plot(nps_fcasts, levels = c(2, 3))
```

![](hierarchical-forecasting_files/figure-html/unnamed-chunk-11-1.png)&lt;!-- --&gt;

---

## Conclusions

- Of the methods we examined, _____ performed the best on the NPS Visitor data.

---

## Other Methods

- Proposed by Hyndman, et al (2016)
    - `hts::MinT()` function
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
